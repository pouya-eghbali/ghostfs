name: Windows E2E Tests

on:
  push:
    branches:
      - master
      - main
  pull_request:
    branches:
      - master
      - main

jobs:
  e2e:
    runs-on: windows-2022

    steps:
      - uses: actions/checkout@v4

      - name: Install WinFSP
        shell: powershell
        run: |
          Write-Host "Installing WinFSP via Chocolatey..."
          choco install winfsp -y --no-progress
          Start-Sleep -Seconds 2

          $found = $false
          foreach ($path in @("C:\Program Files (x86)\WinFsp\inc\winfsp\winfsp.h", "C:\Program Files\WinFsp\inc\winfsp\winfsp.h")) {
            if (Test-Path $path) { $found = $true; break }
          }
          if (-not $found) { Write-Error "WinFSP installation failed"; exit 1 }
          Write-Host "WinFSP installed successfully"

      - name: Setup CMake
        uses: lukka/get-cmake@latest

      - name: Build Windows client
        shell: cmd
        run: |
          cmake -S standalone -B build/standalone -G "Visual Studio 17 2022" -A x64 ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DWINFSP_PATH="C:/Program Files (x86)/WinFsp"
          cmake --build build/standalone --config Release -j %NUMBER_OF_PROCESSORS%

      - name: Setup WSL with Ubuntu
        uses: Vampire/setup-wsl@v4
        with:
          distribution: Ubuntu-22.04
          set-as-default: true

      - name: Install build dependencies in WSL
        shell: wsl-bash {0}
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake g++ libfuse-dev libssl-dev zlib1g-dev fuse

      - name: Build Linux server in WSL
        shell: wsl-bash {0}
        run: |
          cd /mnt/d/a/ghostfs/ghostfs
          cmake -S standalone -B build/linux -DCMAKE_BUILD_TYPE=Release
          cmake --build build/linux -j$(nproc)
          test -f build/linux/GhostFS && echo "Linux server built successfully"

      - name: Start Linux server
        shell: wsl-bash {0}
        run: |
          mkdir -p /data/root/testuser
          cd /mnt/d/a/ghostfs/ghostfs
          nohup ./build/linux/GhostFS --server --root /data/root --bind 0.0.0.0 --port 3444 --auth-port 3445 > /tmp/server.log 2>&1 &
          sleep 3
          pgrep -f "GhostFS.*--server" && echo "Server started" || (cat /tmp/server.log; exit 1)

      - name: Create test user token
        id: auth
        shell: powershell
        run: |
          $output = wsl bash -c 'cd /mnt/d/a/ghostfs/ghostfs && ./build/linux/GhostFS --authorize --host 127.0.0.1 --auth-port 3445 --user testuser --retries -1 2>&1'
          $token = [regex]::Match($output, '[a-f0-9]{32,}').Value
          if ($token) {
            echo "TOKEN=$token" >> $env:GITHUB_OUTPUT
            Write-Host "Token obtained"
          } else {
            Write-Error "Failed to get token: $output"
            exit 1
          }

      - name: Get WSL IP
        id: wsl-ip
        shell: powershell
        run: |
          $ip = (wsl hostname -I).Trim().Split()[0]
          echo "WSL_IP=$ip" >> $env:GITHUB_OUTPUT
          Write-Host "WSL IP: $ip"

      - name: Run E2E Tests
        shell: powershell
        env:
          TOKEN: ${{ steps.auth.outputs.TOKEN }}
          WSL_IP: ${{ steps.wsl-ip.outputs.WSL_IP }}
        run: |
          $ErrorActionPreference = "Continue"
          $passed = 0; $failed = 0

          function Pass($m) { Write-Host "[PASS] $m" -ForegroundColor Green; $script:passed++ }
          function Fail($m) { Write-Host "[FAIL] $m" -ForegroundColor Red; $script:failed++ }

          # Start client
          Write-Host "Starting Windows client..."
          $client = Start-Process -FilePath "build/standalone/Release/GhostFS.exe" `
            -ArgumentList "--client --host $env:WSL_IP --port 3444 -u testuser -t $env:TOKEN G:" `
            -PassThru -NoNewWindow -RedirectStandardOutput "client.log" -RedirectStandardError "client-err.log"

          Start-Sleep -Seconds 5

          if (-not (Test-Path "G:\")) {
            Get-Content "client.log", "client-err.log" -ErrorAction SilentlyContinue
            Write-Error "Mount failed"; exit 1
          }
          Write-Host "Mounted on G:"

          # Tests
          try { Set-Content "G:\t1.txt" -Value "hello"; if (Test-Path "G:\t1.txt") { Pass "Create file" } else { Fail "Create file" } } catch { Fail "Create file: $_" }
          try { Set-Content "G:\t2.txt" -Value "test"; if ((Get-Content "G:\t2.txt" -Raw).Trim() -eq "test") { Pass "Read file" } else { Fail "Read file" } } catch { Fail "Read file: $_" }
          try { New-Item -ItemType Directory "G:\dir1" -Force | Out-Null; if (Test-Path "G:\dir1" -PathType Container) { Pass "Create dir" } else { Fail "Create dir" } } catch { Fail "Create dir: $_" }
          try { New-Item -ItemType Directory "G:\dir2" -Force | Out-Null; 1..3 | %{ Set-Content "G:\dir2\f$_.txt" -Value "x" }; if ((Get-ChildItem "G:\dir2").Count -eq 3) { Pass "List dir" } else { Fail "List dir" } } catch { Fail "List dir: $_" }
          try { Set-Content "G:\del.txt" -Value "x"; Remove-Item "G:\del.txt"; if (-not (Test-Path "G:\del.txt")) { Pass "Delete file" } else { Fail "Delete file" } } catch { Fail "Delete file: $_" }
          try { Set-Content "G:\old.txt" -Value "x"; Move-Item "G:\old.txt" "G:\new.txt"; if ((Test-Path "G:\new.txt") -and -not (Test-Path "G:\old.txt")) { Pass "Rename file" } else { Fail "Rename file" } } catch { Fail "Rename file: $_" }
          try { New-Item -ItemType Directory "G:\a\b\c" -Force | Out-Null; Set-Content "G:\a\b\c\d.txt" -Value "deep"; if (Test-Path "G:\a\b\c\d.txt") { Pass "Nested dirs" } else { Fail "Nested dirs" } } catch { Fail "Nested dirs: $_" }
          try { $b = [byte[]](1..255); [IO.File]::WriteAllBytes("G:\bin.dat", $b); $r = [IO.File]::ReadAllBytes("G:\bin.dat"); if ($b.Length -eq $r.Length) { Pass "Binary file" } else { Fail "Binary file" } } catch { Fail "Binary file: $_" }

          Write-Host "`n=========================================="
          Write-Host "Passed: $passed" -ForegroundColor Green
          Write-Host "Failed: $failed" -ForegroundColor Red
          Write-Host "==========================================`n"

          Stop-Process -Id $client.Id -Force -ErrorAction SilentlyContinue
          if ($failed -gt 0) { exit 1 }

      - name: Logs on failure
        if: failure()
        shell: powershell
        run: |
          Write-Host "=== Client logs ==="
          Get-Content "client.log", "client-err.log" -ErrorAction SilentlyContinue
          Write-Host "=== Server logs ==="
          wsl cat /tmp/server.log 2>$null

      - name: Cleanup
        if: always()
        shell: powershell
        run: |
          Get-Process -Name "GhostFS" -ErrorAction SilentlyContinue | Stop-Process -Force
          wsl pkill -f GhostFS 2>$null
